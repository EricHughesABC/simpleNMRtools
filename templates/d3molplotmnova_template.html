<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .plot-container {
            width: 1000px;
            height: 600px;
            margin: 0 auto;
            overflow: hidden; /* Prevent scrollbars from appearing */
        }
        .tooltip {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            pointer-events: none;
            display: inline-block;
            max-width: 800px; /* Set max-width for the tooltip */
        }

        /* Style for the SVG border */
        svg {
            position: relative; /* Set position relative to make it a positioning context */
        }

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    
        .container {
            display: flex; /* Use flexbox */
            justify-content: center; /* Center the content horizontally */
            margin: 0 auto; /* Set the left and right margins to auto to center the container */
        }

        .group {
            border: 1px solid black;
            border-radius: 10px; /* Adjust the value to change the roundness of the corners */
            display: block;
            margin-right: 10px; /* Add some space between the groups */
            padding: 10px; /* Add padding inside the border */
            padding: 10px; /* Add padding inside the border */
        }

        .group:last-child {
            margin-right: 0; /* Remove margin from the last group */
        }

        .color-container {
            position: relative;
            display: inline-block;
            
        }

        .color-box {
            width: 100px;
            height: 50px;
            border-radius: 7px;
        }

        .striped-rectangle {
            width: 100px;
            height: 50px;
            background: repeating-linear-gradient(90deg, #ccc, #ccc 10px, #fff 10px, #fff 20px);
        }

        .color-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: black; /* Adjust text color as needed */
        }

        .orange { background-color: #FFA500; }
        .green { background-color: #98FB98; }
        .yellow { background-color: yellow; }
        .cyan { background-color: #00FFFF; }
        .grey { background-color: #808080; }
        .blue { background-color: #ADD8E6; }
        .red { background-color: #FF0000; }

       /* Normal button styles */
       button.normal {
            background-color: #ADD8E6;
            color: black;
            border: 2px solid #ADD8E6; 
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        /* Sunken (clicked) button styles */
        button.sunken {
            background-color: #dae3e6;
            box-shadow: inset 0 4px 6px rgba(0, 0, 0, 0.2);
            transform: translateY(2px);
        }
    </style>

    <title>{{title}}</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
    <br>
    <br>

     <!-- SVG container with background molecule image -->

     <div class="plot-container" id="plot-container">
    {% autoescape false %}
    {{svg_container}} 
    {% endautoescape %}
    </div>

    <!-- Tooltip for displaying node information -->
    <div id="tooltip" class="tooltip">Tooltip content</div>
    <br>
  
    <div class="container">
        <div class="group">
            <button title="Quaternary Carbons" style="border: 2px solid orange" class="color-container color-box action-button orange" >
                -C-<sub></sub>
            </button>
            <button title="Methine Carbons" style="border: 2px solid #98FB98" class="color-container color-box action-button green" >
                -CH<sub></sub>
            </button>
            <button title="Methylene Carbons" style="border: 2px solid yellow" class="color-container color-box action-button yellow" >
                -CH<sub>2</sub>
            </button>
            <button title="Methyl Carbons" style="border: 2px solid cyan" class="color-container color-box action-button cyan" >
                -CH<sub>3</sub>
            </button>
        </div>
        <div class="group">
            <!-- <button id="sunkenButton" class="normal color-container color-box action-button">Click Me</button> -->
            <button title="Press to display HMBC links" style="border: 2px solid grey" class="color-container color-box action-button grey" id="hmbcButton">
                HMBC
            </button>
            <button id="sunkenButton" title="Press to hide COSY links" class="normal color-container color-box action-button blue" >
                COSY
            </button>
        </div>
        <div class="group">
            <button title="Information about the current view" id="infoButton" class="color-container color-box action-button white">
                INFO
            </button>   
            <button title="Apply the changes updating the ppm values and atom numbers" class="color-container color-box action-button white"  onclick="updateMovedAtoms()">
                Update
            </button>
            <button title="Export information as JSON for use in assignment in MNOVA" class="color-container color-box action-button white" onclick="exportToMnova()">
                Export
            </button>
            <button title="Open simpleNMR help pages" class="color-container color-box action-button white" onclick="window.open('http://simplenmr.pythonanywhere.com/documentation/index.html', '_blank')">
                Help
            </button>
        </div>
    </div>   

    <script>

    // set up some constants
    const svg_width_eeh = 1000;
    const svg_height_eeh = 600;
    const svg_center_x_eeh = svg_width_eeh / 2;
    const svg_center_y_eeh = svg_height_eeh / 2;

    // Select the SVG element and add an id to it
    d3.select("svg").attr("id", "svg-image");
        
    // Select the first <g> element and add an id to it
    d3.select("#svg-image").select("g").attr("id", "molimage")

    const svgElement = document.querySelector('svg.center');

    // Update the width and height attributes
    svgElement.setAttribute('width', svg_width_eeh);
    svgElement.setAttribute('height', svg_height_eeh);

    // Update the viewBox attribute
    svgElement.setAttribute('viewBox', `0 0 ${svg_width_eeh} ${svg_height_eeh}`);

    {% autoescape false %}
    // smiles string
    const smilesString = "{{smilesString}}";
    // molfile
    const molfile = `{{molFile}}`;
    // working directory
    const workingDirectory = `{{workingDirectory}}`;
    // working filename
    const workingFilename = `{{workingFilename}}`;
    // data from
    const dataFrom = `{{dataFrom}}`;
    // oldjsondata
    const oldjsondata = {{oldjsondata}};
  
    // title
    const title = `{{title}}`;
    {% endautoescape %}
    

        // node offset
    let node_offset = 0;
    if(dataFrom == 'mnova'){
        node_offset = 0;
    }

    // Define scale functions for x and y coordinates
    const xScale = d3.scaleLinear().domain([0, 1]).range([0, 1000]);
    const yScale = d3.scaleLinear().domain([0, 1]).range([0, 600]);

    // define colour blind friendly colours with 50% transparency
    const orange = 'rgba(255, 165, 0, 1)';
    const blue = 'rgba(173, 216, 230, 1)';
    const green = 'rgba(152, 251, 152, 1)';
    const yellow = 'rgba(255, 255, 0, 1)';
    const purple = 'rgba(128, 0, 128, 1)';
    const cyan = 'rgba(0, 255, 255, 1)';
    const grey = 'rgba(128, 128, 128, 1)';

    const black = 'rgba(0, 0, 0, 1)';
    const white = 'rgba(255, 255, 255, 1)';

    // assign colours to parts of the molecule
    const CH3 = cyan;
    const CH2 = yellow;
    const CH = green;
    const C = orange;

    const cosyEdgeColor = blue;
    const cosyEdgeHoverOpacity = 0.0;
    const hmbcEdgeColor = grey;

    const nodeHoverColor = "lightgrey";
    const nodeHoverOpacity = 0.4;
    const textHoverOpacity = 0;

    // define node dimensions
    const nodeRadius = 22;
    const nodeRadiusSmall = 15;
    const nodeRadiusLarge = 26;

    // define edge widths
    const cosyEdgeWidth = 8;
    const hmbcEdgeWidth = 8;
    const noesyEdgeWidth = 8;

    // define font size
    const fontSizeStr = "12px";
    const fontSizeInt = 12;

    const textOffsetInt = 8;

    // Define color scale for nodes based on numProtons
    const colorScale = d3.scaleOrdinal()
      .domain([0, 1, 2, 3])
      .range([C, CH, CH2, CH3]); // Blue, Orange, Green, Red


    // Select the SVG element

    // Initial transformation
    const initialTransform = d3.zoomIdentity.translate(0, 0);

    // Track the current transform
    let currentTransform = initialTransform;

    // Append a group element to hold the content
    const svg = d3.select("#svg-image").attr("transform", initialTransform);

    // Add zoom and pan functionality
    const myZoom = d3.zoom()
        .scaleExtent([0.5, 5])
        .on("zoom", handleZoom);


    svg.call(myZoom);

    // const arrow = d3.select("#arrow");
    const molimage = d3.select("#molimage");

    // Define the graph data
    {% autoescape false %}
    // catoms
    var catoms = {{catoms}};
    // nodes
    var nodes = {{graph_nodes}};
    // nodes_orig
    var nodes_orig = {{orig_nodes}};
    // nodes_now
    var nodes_now = {{graph_nodes}};
    // links
    var links = {{graph_edges}};
    // molgraph
    var molgraph = {{molgraph}};
    // shortest_paths
    var shortest_paths = {{shortest_paths}};
    // best_results
    var best_results = {{best_results}};

  

    var svg_bckgrnd_image_str = `{{svg_container}}`;
    {% endautoescape %}


    // Modify INFO tooltip to display the best results from the optimization with only 2 decimal places
    d3.select("#infoButton")
    .attr("title", `Correlation Penalty: ${best_results.best_weight}, MAE: ${best_results.best_mae.toFixed(2)}, LAE: ${best_results.best_lae.toFixed(2)} (NODE ${best_results.best_lae_atomNumber})`);


    // Set the visible property of the catoms array to false
    // loop through the nodes
    catoms.forEach(node => {
        node.visible = false;
    });

    // Set the visible property of the catoms array to false
    // loop through the nodes
    nodes.forEach(node => {
        // find the id of the node in the catoms array set  visible property to the catom object to true
        const catom = catoms.find(catom => catom.id === node.id);
        if (catom) {
            catom.visible = true;
            catom.ppm =  node.ppm;
            catom.iupacLabel = node.iupacLabel;
            catom.jCouplingVals = node.jCouplingVals;
            catom.jCouplingClass = node.jCouplingClass;
            catom.H1_ppm = node.H1_ppm;
        }
    })

    var catoms_orig = JSON.parse(JSON.stringify(catoms));

    // Set initial positions of nodes and links
    nodes.forEach(node => {
        node.x = xScale(node.x);
        node.y = yScale(node.y);
    });

    nodes_orig.forEach(node => {
        node.x = xScale(node.x);
        node.y = yScale(node.y);
    });

    catoms.forEach(node => {
        node.x = xScale(node.x);
        node.y = yScale(node.y);
    });

    catoms_orig.forEach(node => {
        node.x = xScale(node.x);
        node.y = yScale(node.y);
    });

    // define mapping
    var mapping = {};
    for(var i=0; i<catoms_orig.length; i++) {
        mapping[catoms_orig[i]["id"]] = catoms_orig[i]["id"];
    }

    nodes = JSON.parse(JSON.stringify(catoms.filter(node => node.visible)));
    

    // Set initial positions of nodes and links

    const linksGroup = d3.select("svg g").attr("class", "links-group");

    // Filter links that have the attribute cosy as true
    // const cosyLinks = links.filter(link => link.cosy);
    const cosyLinks = links.filter(eachLink => eachLink.cosy);
    const hmbcLinksData = links.filter(eachLink => eachLink.hmbc);


    function colorHmbcLinksByDistance(mapping, offset) {
        d3.selectAll(".hmbc-link").attr("stroke", d => {
            const sourceId = mapping[d.source] - offset;
            const targetId = mapping[d.target] - offset;
            
            // Check if the path length is greater than 2 (long range)
            if (shortest_paths[sourceId] && 
                shortest_paths[sourceId][targetId] && 
                shortest_paths[sourceId][targetId] > 2) {
                return "#FF5733"; // Red color for long range HMBC links
            } else {
                return "#808080"; // Grey color for short range HMBC links
            }
        });
    }

    function reorderElements() {
        const svg = d3.select('svg');
        
        // Get both groups
        const linksGroupNode = svg.select('.links-group').node();
        const nodesGroupNode = svg.select('.nodes-group').node();
        
        if (!linksGroupNode || !nodesGroupNode) {
            console.error("Could not find links or nodes group");
            return;
        }
        
        // CRITICAL: Ensure linksGroup comes before nodesGroup in SVG
        // Remove and re-insert linksGroup as the first child
        const svgNode = svg.node();
        svgNode.removeChild(linksGroupNode);
        svgNode.insertBefore(linksGroupNode, nodesGroupNode);
        
        // Now reorder links within the linksGroup (COSY → grey HMBC → red HMBC)
        d3.selectAll(".cosy-link").each(function() {
            linksGroupNode.appendChild(this);
        });
        
        d3.selectAll(".hmbc-link").each(function() {
            const color = d3.select(this).attr("stroke");
            if (color === "#808080" || color === "rgb(128, 128, 128)") {
                linksGroupNode.appendChild(this);
            }
        });
        
        d3.selectAll(".hmbc-link").each(function() {
            const color = d3.select(this).attr("stroke");
            if (color === "#FF5733" || color === "rgb(255, 87, 51)") {
                linksGroupNode.appendChild(this);
            }
        });
        console.log("Elements reordered: links before nodes");
    }

    // Create the COSY links to start
    // Create a group for links
    const link = linksGroup.selectAll(".links-group")
        .data(cosyLinks)
        .enter().append("line")
        .attr("class", "link")
        .attr("class", "cosy-link")
        .attr("stroke", cosyEdgeColor)
        .attr("source", d => d.source)
        .attr("target", d => d.target)
        .attr("x1", d => nodes.find(node => node.id === d.source).x)
        .attr("y1", d => nodes.find(node => node.id === d.source).y)
        .attr("x2", d => nodes.find(node => node.id === d.target).x)
        .attr("y2", d => nodes.find(node => node.id === d.target).y)
        .attr("stroke-width", cosyEdgeWidth); // Set the stroke width to 8 pixels


    // Edge initialization
    const hmbclinks_svg = linksGroup.selectAll(".links-group")
        .data(hmbcLinksData)
        .enter().append("line")
        .attr("class", "link hmbc-link")
        .attr("stroke", hmbcEdgeColor)
        .attr("x1", d => nodes.find(node => node.id === d.source).x)
        .attr("y1", d => nodes.find(node => node.id === d.source).y)
        .attr("x2", d => nodes.find(node => node.id === d.target).x)
        .attr("y2", d => nodes.find(node => node.id === d.target).y)
        .attr("source", d => d.source)
        .attr("target", d => d.target)
        .attr("opacity", 0) // Initially hidden with opacity
        .attr("stroke-width", hmbcEdgeWidth);

    // Color HMBC links by distance
    colorHmbcLinksByDistance(mapping, node_offset);



    const svg_display = d3.select('svg')
    const nodesGroup = d3.select("svg g").attr("class", "nodes-group");

    // Create the nodes
    const allnodes = nodesGroup.selectAll(".nodes-group")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .attr("atomNumber", d => d.atomNumber)
      .attr("id", d => d.id)
      .attr("ppm", d => d.ppm)
      .attr("ppm_calculated", d => d.ppm_calculated)
      .attr("numProtons", d => d.numProtons)
      .attr("x", d => d.x)
      .attr("y", d => d.y)
      .on("mouseover", (event, d) => handleMouseOver(event, d)) // Call function when mouseover
      .on("mouseout", (event, d) => handleMouseOut(event, d))  // Call function when mouseout
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));


    // Add circles to represent nodes
    allnodes.append("circle")
      .attr("r", nodeRadius)
      .attr("fill", d => colorScale(d.numProtons)) // Set fill color based on numProtons

    // Append atomNumber text
    allnodes.append("text")
        .attr("class", "node-text-atomNumber")
        .text(d => `${d.atomNumber}`) // Display the id
        .attr("dy", -textOffsetInt) // Center the text vertically
        .attr("font-size", fontSizeStr) // Set font size to 16 pixels
        .attr("text-anchor", "middle"); // Center the text horizontally

    // Append ppm text
    allnodes.append("text")
        .attr("class", "node-text-ppm")
        .text(d => d.ppm.toFixed(2)) // Display the id
        .attr("dy", +textOffsetInt) // Center the text vertically
        .attr("font-size", fontSizeStr) // Set font size to 16 pixels
        .attr("text-anchor", "middle"); // Center the text horizontally

    // Tooltip for node hover
    const tooltip = d3.select("#tooltip");

    tooltip.style("opacity", 0);

    let hmbcLinks = []; // Track hmbc links separately
    var circlenodes = document.querySelectorAll('.node circle');
    var textnodes = document.querySelectorAll('.node text');

    // split textnodes into atomNumber and ppm
    var nodetextppm = [];
    var nodetextatomNumber = [];
    for(var i=0; i<textnodes.length; i+=2) {
        nodetextatomNumber.push(textnodes[i]);
        nodetextppm.push(textnodes[i+1]);
    }

    reorderElements();

// Transform state variables
let panX = 0, panY = 0;
let scaleLevel = 1;
let rotation = 0;
let lastTransform = d3.zoomIdentity;
var dragstartedFlag = false;

// Drag handlers
function dragstarted(event, d) {
    link.style("opacity", 0);
    d3.select(this).raise().classed("active", true);
    dragstartedFlag = true;
}

function dragged(event, d) {
    d.x = event.x;
    d.y = event.y;
    link.filter(l => l.source === d.id).attr("x1", d.x).attr("y1", d.y);
    link.filter(l => l.target === d.id).attr("x2", d.x).attr("y2", d.y);
    hmbclinks_svg.filter(l => l.source === d.id).attr("x1", d.x).attr("y1", d.y);
    hmbclinks_svg.filter(l => l.target === d.id).attr("x2", d.x).attr("y2", d.y);

    d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
}

function dragended(event, d) {
    d3.select(this).classed("active", false);
    dragstartedFlag = false;
    handleMouseOver(event, d);
}



// Helper function to apply the combined transform
function applyTransform() {
    // Order: pan, then centered scale, then rotation
    molimage.attr("transform", 
        `translate(${panX}, ${panY}) ` +
        `translate(${svg_center_x_eeh}, ${svg_center_y_eeh}) ` +
        `scale(${scaleLevel}) ` +
        `rotate(${rotation}) ` +
        `translate(${-svg_center_x_eeh}, ${-svg_center_y_eeh})`
    );
}

// Helper function to update size-dependent elements
function updateScaledElements() {
    // Keep nodes the same size regardless of zoom level
    allnodes.selectAll("circle")
        .attr("r", nodeRadius / scaleLevel);

    // Keep text elements adjusted
    allnodes.selectAll(".node-text-atomNumber")
        .attr("font-size", `${fontSizeInt / scaleLevel}px`)
        .attr("dy", `${-textOffsetInt / scaleLevel}px`);

    allnodes.selectAll(".node-text-ppm")
        .attr("font-size", `${fontSizeInt / scaleLevel}px`)
        .attr("dy", `${textOffsetInt / scaleLevel}px`);

    // Keep link stroke width constant
    linksGroup.selectAll("line")
        .attr("stroke-width", `${hmbcEdgeWidth / scaleLevel}px`);
}



function handleZoom(event) {
    const { x, y, k } = event.transform;

    // Only update pan position for drag events (not wheel/zoom)
    if (event.sourceEvent) {
        if (event.sourceEvent.type === 'mousemove' || event.sourceEvent.type === 'touchmove') {
            // This is a pan/drag - accumulate the delta
            const dx = x - lastTransform.x;
            const dy = y - lastTransform.y;
            panX += dx;
            panY += dy;
        }
    }

    // Update scale level
    scaleLevel = k;
    lastTransform = event.transform;

    applyTransform();
    updateScaledElements();
}



// Function to handle rotation
function rotateSVG(angle) {
    rotation = (rotation + angle) % 360;
    
    applyTransform();

    // Keep text elements horizontal by applying a counter-rotation
    allnodes.selectAll(".node-text-atomNumber")
        .attr("transform", `rotate(${-rotation})`);
    allnodes.selectAll(".node-text-ppm")
        .attr("transform", `rotate(${-rotation})`);
}

// Add keydown event listener for rotation
d3.select("body").on("keydown", (event) => {
    if (event.key === "R" && event.shiftKey) {
        rotateSVG(90);
    }
    else if (event.key === "L" && event.shiftKey) {
        rotateSVG(-90);
    }
    else if (event.key === "r" || event.key === "R") {
        console.log("Rotate SVG");
        rotateSVG(10);
    }
    else if (event.key === "l" || event.key === "L") {
        rotateSVG(-10);
    }
});

    // Function to find nearest neighbors and non-nearest neighbours of a node with a specific attribute
    function findNearestNeighbors(nodeId, attribute) {
        const neighbors = [];
        const nonNeighbors = [];

        // Iterate through the links
        links.forEach(link => {
            if (link[attribute] && (link.source === nodeId || link.target === nodeId)) {
                neighbors.push(link.source === nodeId ? link.target : link.source);
            }
        });

        // Iterate through all nodes to find non-neighbors
        nodes.forEach(node => {
            if (node.id !== nodeId && !neighbors.includes(node.id)) {
                nonNeighbors.push(node.id);
            }
        });

        return { neighbors, nonNeighbors };
    }

    // Function to display tooltip
    function displayTooltip(event, d){
        // generate the html sub string for d.H1 ppm which is an array

        var circlenodes = document.querySelectorAll('.node circle');

        // When numProtons is 0
        if (d.numProtons == 0) {
            if (d.ppm_calculated.length == 0) {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} ppm`;
            }
            else {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} (${d.ppm_calculated.toFixed(2)}) ppm`;
            }
        } 
        else if (d.H1_ppm.length == 1) {
            // Expect d.H1 to be an array of length 1
            if (d.ppm_calculated.length == 0) {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} ppm`;
            }
            else {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} (${d.ppm_calculated.toFixed(2)}) ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} ppm`;
            }
                // var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} ppm`;
            // if jCouplingVals is not empty, add the J coupling values
            if (d.jCouplingClass.length > 0) {
                if (d.jCouplingClass === "m" || d.jCouplingClass === "s") {
                    htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass}`;
                } 
                else {
                // htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass[0]} : ${d.jCouplingVals[0]} Hz`;
                    htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass} : ${d.jCouplingVals} Hz`;
                }
            }
        } 
        else {
            // Expect d.H1 to be an array of length 2
            if (d.ppm_calculated.length == 0) {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} & ${d.H1_ppm[1].toFixed(2)} ppm`;
            }
            else {
                var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} (${d.ppm_calculated.toFixed(2)}) ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} & ${d.H1_ppm[1].toFixed(2)} ppm`;
            }
            // var htmlstr =  `C${d.atomNumber} ${d.iupacLabel} <b>${generateHTMLnumProtonsString(d.numProtons)}</b>: <sup>13</sup>C = ${d.ppm.toFixed(2)} ppm, <sup>1</sup>H = ${d.H1_ppm[0].toFixed(2)} & ${d.H1_ppm[1].toFixed(2)} ppm`;
            // add the J coupling values if not empty
            // print("d.jCouplingClass.length, d.jCouplingVals.length", d.jCouplingClass.length, d.jCouplingVals.length);
            if(d.jCouplingClass.length > 0) {
                // htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass[0]} : ${d.jCouplingVals[0]} Hz, ${d.jCouplingClass[1]} : ${d.jCouplingVals[1]} Hz`;
                if (d.jCouplingClass === "m" || d.jCouplingClass === "s") {
                    htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass}`;
                }
                else {
                    htmlstr = htmlstr + `<br>J's : ${d.jCouplingClass} : ${d.jCouplingVals} Hz`;
                }
            }
        }

        tooltip.transition()
            .duration(200)
            .style("opacity", 9.75);
        tooltip.html(htmlstr)    
            .style("left", (-99999) + "px")
            .style("top", (-99999) + "px")
            .style("display", "inline-block");

        var tooltipDiv = d3.select('#tooltip');

        // Get the corresponding DOM element
        var tooltipNode = tooltipDiv.node();

        var pageWidth = document.documentElement.clientWidth;

        // Get the dimensions of the div element
        var tooltipWidth = tooltipNode.clientWidth;
        var tooltipHeight = tooltipNode.clientHeight;
        var tooltipX = (pageWidth - tooltipWidth) / 5;

        tooltip.html(htmlstr) 
            .style("left", (tooltipX) + "px")
            .style("top", (25) + "px")
            .style("display", "inline-block");

        // Increase the radius of the hovered over node using d.id
        circlenodes.forEach(function(circleNode) {
            if (circleNode.__data__.id == d.id) {
                circleNode.setAttribute("r", nodeRadiusLarge/scaleLevel);
            }
        });
    }



    // Function to highlight HMBC neighbors (updated)
    function highlightHMBCneighbors(event, d) {

        // check if the HMBC button is sunken and if it is release it and  reset the HMBC links to hidden and default colour
        if (d3.select("#hmbcButton").classed("sunken")){
            hmbcVisible = false;
            d3.select("#hmbcButton").classed("sunken", false);
            hmbclinks_svg.attr("opacity", 0);
            // hmbclinks_svg.attr("stroke", hmbcEdgeColor);
            colorHmbcLinksByDistance(mapping, node_offset);

            // check if the COSY button is not sunken, if it is not, set the opacity of the cosy links to 1
            if (!d3.select("#sunkenButton").classed("sunken")){
                // change the opacity of the cosy links to 1
                link.style("opacity", 1);
            }
        }
        
        var circlenodes = document.querySelectorAll('.node circle');
        
        // Define the attribute to find nearest neighbors
        const attribute = "hmbc";
        const attribute2 = "noesy";
        
        // Call the function to find nearest neighbors
        const hmbcNearestNodes = findNearestNeighbors(d.id, attribute);
        const noesyNearestNodes = findNearestNeighbors(d.id, attribute2);

        const nearestNeighborIDs = hmbcNearestNodes.neighbors;
        const nearestNeighborIDs2 = noesyNearestNodes.neighbors;

        // change the opacity of the nodes to 0.5
        hmbcNearestNodes.nonNeighbors.forEach(nonNeighborId => {
            circlenodes.forEach(function(circleNode) {
                if (circleNode.__data__.id == nonNeighborId) {
                    circleNode.style.opacity = nodeHoverOpacity;
                    circleNode.setAttribute("r", nodeRadiusSmall/scaleLevel);
                }
            });
        });
        
        // set the font colour to grey for all the text nodes
        hmbcNearestNodes.nonNeighbors.forEach(i => {
            textnodes.forEach(function(textNode) {
                if (textNode.__data__.id == i) {
                    textNode.style.fill = nodeHoverColor;
                    textNode.style.opacity = textHoverOpacity;
                }
            });
        });

        // increase the size of the circles for the nearest neighbors
        nearestNeighborIDs.forEach(i => {
            circlenodes.forEach(function(circleNode) {
                if (circleNode.__data__.id == i) {
                    circleNode.setAttribute("r", nodeRadiusLarge/scaleLevel);
                }
            });
        });

        // change the opacity of the cosy links to 0
        link.style("opacity", 0);

        // First reset all HMBC links to invisible if the global toggle is off
        if (!hmbcVisible) {
            hmbclinks_svg.attr("opacity", 0);
        }

        // Now show only connections to the current node, regardless of global toggle
        hmbclinks_svg.filter(l => l.source === d.id).attr("opacity", 1);
        hmbclinks_svg.filter(l => l.target === d.id).attr("opacity", 1);
    }

    // Function to handle mouseover event
    function handleMouseOver(event, d) {

        if (dragstartedFlag) {
            return;
        }   
        // Display tooltip
        if (event) {
            displayTooltip(event, d);
            highlightHMBCneighbors(event,d);
        }
    }

    // Function to handle mouseout event
    function handleMouseOut(event, d) {

        var circlenodes = document.querySelectorAll('.node circle');

        if (dragstartedFlag) {
            return;
        }   
        // change the opacity of the text nodes to 1
        // reset the font colour of the text in the nodes to black
        textnodes.forEach( t => {
            t.style.opacity = 1;
            t.style.fill = 'black';
        });

        // set the opacity of all the nodes to 1
        circlenodes.forEach( c => {
            c.style.opacity = 1;
        });

        // reset the fill color of all the circles to their original color
        // loop through the nodes to get the id and numProtons
        nodes.forEach(d => {
            circlenodes.forEach( function(circleNode) {
                if (circleNode.__data__.id == d.id) {
                    circleNode.style.fill = colorScale(d.numProtons);
                    circleNode.setAttribute("r", nodeRadius/scaleLevel);
                }
            });
        });

        // Hide the tooltip
        tooltip.transition()
                .duration(100)
                .style("opacity", 0);
        // Revert the radius
        d3.select(event.target)
            .transition()
            .duration(100)
            .attr("r", nodeRadius/scaleLevel);

        // Remove hmbc links
        hmbcLinks.forEach(link => link.remove());
        hmbcLinks = []; // Clear the hmbc links array

        // change the opacity of the cosy links to 1
        link.style("opacity", 1);

        // hmbclinks_svg.style("opacity", 0);
        hmbclinks_svg.filter(l => l.source === d.id).attr("opacity", 0);
        hmbclinks_svg.filter(l => l.target === d.id).attr("opacity", 0);

        if (d3.select("#infoButton").classed("sunken")){
            laeVisible = false;
            d3.select("#infoButton").classed("sunken", false);

        }
    }

    function generateHTMLnumProtonsString(index) {
        switch (index) {
            case 0:
            return "-C-";
            case 1:
            return "-CH";
            case 2:
            return "-CH<sub>2</sub>";
            case 3:
            return "-CH<sub>3</sub>";
            default:
            return "<p>Invalid index</p>";
        }
    }

    function updateMovedAtoms() {
        // Update the moved atoms

        if( !updateMovedAtoms3()){
            return
        };

        nodes = JSON.parse(JSON.stringify(catoms.filter(node => node.visible)));

        // Select all circle elements with the class 'node' in the nodesGroup
        var circlenodes = nodesGroup.selectAll('.node circle');

        // Add circles to represent nodes
        // svg.selectAll(".node circle")

        // update node colour
        nodesGroup.selectAll(".node circle")
            .data(nodes)
            .style("fill", d => colorScale(d.numProtons))
            .raise(); // Display the id

        // update atomNumber
        nodesGroup.selectAll(".node text.node-text-atomNumber")
            .data(nodes)
            .text(d => `${d.atomNumber}`)
            .raise(); // Display the id

        // update the ppm text
        nodesGroup.selectAll(".node text.node-text-ppm")
            .data(nodes)
            .text(d => d.ppm.toFixed(2))
            .raise(); // Display the ppm

        // move the nodes
        nodesGroup.selectAll(".node")
            .data(nodes)
            .attr("class", "node")
            .transition()
            .duration(1000)
            .attr("transform", d => `translate(${d.x},${d.y})`);

        // update the cosy links
        svg.selectAll(".link")
            .data(cosyLinks)
            .attr("x1", d => nodes.find(node => node.id === d.source).x)
            .attr("y1", d => nodes.find(node => node.id === d.source).y)
            .attr("x2", d => nodes.find(node => node.id === d.target).x)
            .attr("y2", d => nodes.find(node => node.id === d.target).y);

        // update the hmbc links
        svg.selectAll(".link")
            .data(hmbcLinksData)
            .attr("x1", d => nodes.find(node => node.id === d.source).x)
            .attr("y1", d => nodes.find(node => node.id === d.source).y)
            .attr("x2", d => nodes.find(node => node.id === d.target).x)
            .attr("y2", d => nodes.find(node => node.id === d.target).y);

        // recalculate the MAE and LAE

        var mae = 0.0;
        var lae_best = 0.0;
        var lae_best_atomNumber = -1;
        
        for(var i=0; i<nodes.length; i++) {
            var mae_latest = Math.abs(nodes[i].ppm - nodes[i].ppm_calculated);

            if (mae_latest > lae_best) {
                lae_best = mae_latest;
                lae_best_atomNumber = nodes[i].atomNumber;
            }
            mae += mae_latest           
        }
        mae = mae/nodes.length;


        // define mapping
        for(var i=0; i<catoms_orig.length; i++) {
            mapping[catoms_orig[i]["id"]] = catoms_orig[i]["id"];
        }

        var catoms_orig_dict = {};
        for(var i=0; i<catoms_orig.length; i++) {
            catoms_orig_dict[catoms_orig[i]["atomNumber"]] = catoms_orig[i]["id"];
        }

        for(var i=0; i<nodes.length; i++) {
            var id1 = nodes[i]["id"];
            var atomNumber1 = nodes[i]["atomNumber"];
            var id2 = catoms_orig_dict[atomNumber1];
            mapping[nodes[i]["id"]] = id2;
        }


        // recaclulate correlation penalty
        var best_weight = computeTotalWeight2D(links, mapping, shortest_paths, node_offset);

        // update the best results
        best_results.best_weight = best_weight;
        best_results.best_mae = mae;
        best_results.best_lae = lae_best;
        best_results.best_lae_atomNumber = lae_best_atomNumber;

        // update the INFO tooltip
        d3.select("#infoButton")
        .attr("title", `Correlation Penalty: ${best_results.best_weight}, MAE: ${best_results.best_mae.toFixed(2)}, LAE: ${best_results.best_lae.toFixed(2)} (NODE ${best_results.best_lae_atomNumber})`);
        
        colorHmbcLinksByDistance(mapping, node_offset);
        reorderElements();
    }

    function updateMovedAtoms3() {

        // Find the moved nodes and store them in the moved_nodes array
        const moved_nodes = [];
        const removed = [];
        nodes.forEach((node1, index) => {
            const node2 =  catoms_orig[index];
            if (node1.x !== node2.x || node1.y !== node2.y) {
                moved_nodes.push(JSON.parse(JSON.stringify(node1)));
                removed.push(false)
            }
        });

        if(moved_nodes.length == 0){
            return false;
        }


        // Find the closest nodes to the moved nodes
        // Store the indices of the moved nodes and the closest nodes in the closest array
        // keep also the distance between the moved node and the closest node
        const closest_nodes = [];
        const closest_catoms = [];
        moved_nodes.forEach((node1, idx) => {
            // Calculate Euclidean distance between the moved node and all other nodes
            const distances_nodes = catoms_orig.map(node2 => 
                Math.pow(node1.x - node2.x, 2) + Math.pow(node1.y - node2.y, 2)
            );
            
            // Find the closest node
            const minValue1 = Math.min(...distances_nodes);  // Gets the minimum value, which is 3
            const closest_node_idx = distances_nodes.indexOf(minValue1);  // Gets the index, which is 3 (index = 3)

            // Append the index of the moved node and the closest node to the result array
            closest_nodes.push([node1.atomNumber, catoms_orig[closest_node_idx].atomNumber, minValue1]);
        });

        updateNodesEEH3( closest_nodes, moved_nodes, removed);
            // check if all items in removed are true then return false

        if(removed.every(Boolean)){
            return false;
        }

        for(var i=0; i<removed.length; i++) {
            if (removed[i] == true) {
                continue;
            }
            var atomNumber1 = closest_nodes[i][0];
            var atomNumber2 = closest_nodes[i][1];

            // find node1 in the catoms array
            var node1 = moved_nodes.find(node => node.atomNumber === atomNumber1);
            var node2 = catoms.find(catom => catom.atomNumber === atomNumber2);

            // move over information from node1 to node2
            node2["ppm"] = node1["ppm"];
            node2["H1_ppm"] = node1["H1_ppm"];
            node2["jCouplingVals"] = node1["jCouplingVals"];
            node2["jCouplingClass"] = node1["jCouplingClass"];
            node2["id"] = node1["id"];
        }

        // uddate the visible flags in the catoms array
        for(var i=0; i<removed.length; i++) {
            if (removed[i] == true) {
                continue;
            }
            var atomNumber1 = closest_nodes[i][0];
            // var atomNumber2 = closest_nodes[i][1];
            // find node with atomNumber1 in the catoms array
            var node1 = catoms.find(catom => catom.atomNumber === atomNumber1);
            node1.visible = false;
        }

        for(var i=0; i<removed.length; i++) {
            if (removed[i] == true) {
                continue;
            }
            // var atomNumber1 = closest_nodes[i][0];
            var atomNumber2 = closest_nodes[i][1];
            // find node with atomNumber1 in the catoms array
            var node1 = catoms.find(catom => catom.atomNumber === atomNumber2);
            node1.visible = true;
        }
        return true;
    }

    function computeTotalWeight2D(links, mapping, shortestPaths, node_offset) {
        let totalWeight = 0;

        links.forEach(link => {
            const u = link.source;
            const v = link.target;
            const d = link;

            if (d.cosy || d.hmbc) {
                const uu = mapping[u] - node_offset;
                const vv = mapping[v] - node_offset;


                if(uu == vv) {
                    return;
                }

                if (d.cosy) {
                    let weight = shortestPaths[uu][vv];
                    totalWeight += Math.pow(weight - 1, 3);
                }
                if (d.hmbc) {
                    let weight = shortestPaths[uu][vv];
                    if (weight < 3) {
                        weight = 2;
                    }
                    totalWeight += Math.pow(weight - 2, 3);
                }
            }
        });
        return totalWeight;
    }

    function updateNodesEEH3(closest_nodes, moved_nodes, removed) {

        // first check if the moved node will be going to a position that has the same number of protons
        // if it is not, then remove the moved node from the moved_nodes array
        // by setting the removed flag to true

        for(var j=0; j<closest_nodes.length; j++) {
            var atomNumber1 = closest_nodes[j][0];
            var atomNumber2 = closest_nodes[j][1];
            var minValue = closest_nodes[j][2];

            // find node1 in the catoms array
            var node1 = catoms.find(catom => catom.atomNumber === atomNumber1);
            var node2 = catoms.find(catom => catom.atomNumber === atomNumber2);

            if (node1.numProtons != node2.numProtons) {
                removed[j] = true;
            }
            if (node1.atomNumber == node2.atomNumber) {
                removed[j] = true;
            }
        }
        for(var j=0; j<closest_nodes.length; j++) {

            if (removed[j] == true) {
                continue;
            }
            var atomNumber1 = closest_nodes[j][0];
            var atomNumber2 = closest_nodes[j][1];
            var minValue = closest_nodes[j][2];

            // find node1 in the catoms array
            var node1 = catoms.find(catom => catom.atomNumber === atomNumber1);
            var node2 = catoms.find(catom => catom.atomNumber === atomNumber2);

            // destination in the moved_nodes array
            dest_found = moved_nodes.find(moved_node => moved_node.atomNumber === atomNumber2) == undefined ? false : true;
            dest_idx = moved_nodes.findIndex(moved_node => moved_node.atomNumber === atomNumber2);

            if (!dest_found) {
                // check if the destination node is visible
                // if it is then that means the node is being moved to a position that is free and that is allowed
                if (node2.visible) {
                    removed[j] = true;
                }
                else {
                    removed[j] = false;
                }
            }
            else {
                // check that if the destination node has been removed or not
                if (removed[dest_idx] == true) {
                    removed[j] = true;
                }
                else {
                    removed[j] = false;
                }
            }
        }
    }

    function exportToMnova() {

        var workingDirectory = "{{workingDirectory}}";
        var workingFilename = "{{workingFilename}}";

        // create the json filename
        var jsonFilename = workingFilename + '_assignments_from_simplemnova.json';

        // add the working directory to the jsonFilename Does not work
        // var jsonFilename = workingDirectory + '/' + jsonFilename;

        var nodes_export = JSON.parse(JSON.stringify(nodes));

        nodes_export.forEach(node => {
            node.x = xScale.invert(node.x);
            node.y = yScale.invert(node.y);
        });

        catoms_orig.forEach(node => {
            node.x = xScale.invert(node.x);
            node.y = yScale.invert(node.y);
        });

        catoms.forEach(node => {
            node.x = xScale.invert(node.x);
            node.y = yScale.invert(node.y);
        });

        nodes_orig.forEach(node => {
            node.x = xScale.invert(node.x);
            node.y = yScale.invert(node.y);
        });

        var nodes_data ={};
        nodes_data['nodes_orig'] = catoms_orig;
        nodes_data['nodes_now'] = nodes_export;
        nodes_data['links'] = links;

        // add smilesString and molfile to the nodes_data
        nodes_data['smilesString'] = smilesString;
        nodes_data['molfile'] = molfile;

        nodes_data['dataFrom'] = dataFrom;
        nodes_data['oldjsondata'] = oldjsondata;

        nodes_data['molgraph'] = molgraph;
        nodes_data['shortest_paths'] = shortest_paths;
        //  get the contents of the svg element convert to string
        nodes_data['svg'] = svg_bckgrnd_image_str;



        nodes_data['catoms'] = catoms;
        nodes_data['catoms_orig'] = catoms_orig;
        nodes_data['best_results'] = best_results;
        nodes_data['workingDirectory'] = workingDirectory;
        nodes_data['workingFilename'] = workingFilename;
        nodes_data['title'] = title;


        // save the json string to a file
        var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(nodes_data, null, 2));
        var a = document.createElement('a');
        a.href = 'data:' + data;
        a.download = jsonFilename;
        a.innerHTML = 'download JSON';
        a.click();

        // Scale nodes back again
        catoms_orig.forEach(node => {
            node.x = xScale(node.x);
            node.y = yScale(node.y);
        });

        catoms.forEach(node => {
            node.x = xScale(node.x);
            node.y = yScale(node.y);
        });
    }


    const cosybutton = document.getElementById('sunkenButton');

    // Toggle between 'sunken' and 'normal' styles when clicked
    let linksVisible = true;
    cosybutton.addEventListener('click', function() {
        cosybutton.classList.toggle('sunken');

        if (linksVisible) {
            d3.selectAll(".cosy-link").style("display", "none");
        } else {
            d3.selectAll(".cosy-link").style("display", "inline");
        }
        linksVisible = !linksVisible;
    });


    // Toggle code
    const hmbcbutton = document.getElementById('hmbcButton');
    let hmbcVisible = false;

    function toggleHmbcVisibility() {
        hmbcbutton.classList.toggle('sunken');
        hmbcVisible = !hmbcVisible;
        
        if (hmbcVisible) {
            // Show all HMBC edges with opacity
            d3.selectAll(".hmbc-link").attr("opacity", 1);
            // If the cosy button is not sunken, set the opacity of the cosy links to 0
            if (!d3.select("#sunkenButton").classed("sunken")) {
                // change the opacity of the cosy links to 0
                link.style("opacity", 0);
            }
        } else {
            // Hide all HMBC edges with opacity
            d3.selectAll(".hmbc-link").attr("opacity", 0);
            // If the cosy button is not sunken, set the opacity of the cosy links to 1
            if (!d3.select("#sunkenButton").classed("sunken")) {
                // change the opacity of the cosy links to 1
                link.style("opacity", 1);       
            }
        }
    }


    hmbcbutton.addEventListener('click', toggleHmbcVisibility);

    const infobutton = document.getElementById('infoButton');

    // Toggle between 'sunken' and 'normal' styles when clicked
    let laeVisible = true;
    infobutton.addEventListener('click', function() {
        infobutton.classList.toggle('sunken');

        if (d3.select("#infoButton").classed("sunken")){
            laeVisible = true;
        }
        else {
            laeVisible = false;
        }

        // check if infoButton is sunken
        

        if (laeVisible) {
            // select all the nodes where abs(ppm - ppm_calculated) is greater than 10ppm
            // and set the edge node color to red


            // Assuming allnodes is already defined as in your code
            allnodes.each(function(d) {
                // 'this' refers to the current DOM element
                const ppm = d.ppm;
                const ppm_calculated = d.ppm_calculated;
                if (Math.abs(ppm - ppm_calculated) > 10) {
                    d3.select(this).select("circle").style("fill", "pink");
                }
            });

            // set the best lae node to red using the atomNumber and lae_best_atomNumber

            allnodes.each(function(d) {
                const atomNumber = d.atomNumber;
                if (atomNumber == best_results.best_lae_atomNumber) {
                    d3.select(this).select("circle").style("fill", "red");
                }
            });

        } else {

            // Assuming allnodes is already defined as in your code
            allnodes.each(function(d) {
                const numProtons = d.numProtons;
                // Select the circle within the current node group and reset its fill color
                d3.select(this).select("circle").style("fill", colorScale(numProtons));
            });

        }
        laeVisible = !laeVisible;
    });


  </script>
</body>
</html>